package {	import Box2D.Dynamics.b2ContactListener;	import Box2D.Dynamics.Contacts.b2Contact;	import Box2D.Collision.b2Manifold;	import Box2D.Collision.b2WorldManifold;	import Box2D.Dynamics.b2ContactImpulse;	import Box2D.Dynamics.b2Fixture;	import Box2D.Dynamics.b2Body;	import Box2D.Common.Math.b2Vec2;	import Box2D.Common.Math.b2Math;	import Box2D.Common.b2Settings;	import Box2D.Collision.b2ManifoldPoint;	import Box2D.Collision.b2ContactID;	public class EntityContactListener extends b2ContactListener	{		/**		 * Called when two fixtures begin to touch.		 */		override public function BeginContact(contact:b2Contact):void		{		}		/**		 * Called when two fixtures cease to touch.		 */		override public function EndContact(contact:b2Contact):void		{		}		/**		 * This is called after a contact is updated. This allows you to inspect a		 * contact before it goes to the solver. If you are careful, you can modify the		 * contact manifold (e.g. disable contact).		 * A copy of the old manifold is provided so that you can detect changes.		 * Note: this is called only for awake bodies.		 * Note: this is called even when the number of contact points is zero.		 * Note: this is not called for sensors.		 * Note: if you set the number of contact points to zero, you will not		 * get an EndContact callback. However, you may get a BeginContact callback		 * the next step.		 */		override public function PreSolve(contact:b2Contact, oldManifold:b2Manifold):void		{			if(! contact.IsTouching())			{				return;			}						var worldManifold:b2WorldManifold = new b2WorldManifold();			contact.GetWorldManifold(worldManifold);			var state1:Vector.<uint> = new Vector.<uint>();			var state2:Vector.<uint> = new Vector.<uint>();			//look for new contacts			b2GetPointStates(state1, state2, oldManifold, contact.GetManifold());			var fixtureA:b2Fixture = contact.GetFixtureA();			var fixtureB:b2Fixture = contact.GetFixtureB();			var bodyA:b2Body = fixtureA.GetBody();			var bodyB:b2Body = fixtureB.GetBody();			var entityA:PhysicalEntity = bodyA.GetUserData();			var entityB:PhysicalEntity = bodyB.GetUserData();			// if there is a new contact			if (state2[0] == b2PointState.ADD_STATE)			{				var point:b2Vec2 = worldManifold.m_points[0];				var vA:b2Vec2 = bodyA.GetLinearVelocityFromWorldPoint(point);				var vB:b2Vec2 = bodyB.GetLinearVelocityFromWorldPoint(point);				var velocity:Number = b2Math.Dot(b2Math.SubtractVV(vA,vB),worldManifold.m_normal);				var iA:b2Vec2 = b2Math.MulFV(bodyA.GetMass(),vA);				var iB:b2Vec2 = b2Math.MulFV(bodyB.GetMass(),vB);				var impulse:Number = b2Math.Dot(b2Math.SubtractVV(iA,iB),worldManifold.m_normal);// vClosing.x * worldManifold.m_normal.x + vClosing.y * worldManifold.m_normal.y;				entityA.hit(impulse);				entityB.hit(impulse);				entityA.playImpactSound(velocity);				entityB.playImpactSound(velocity);				point = null;				vA = null;				vB = null;				iA = null;				iB = null;			}						var friction:Number = b2Settings.b2MixFriction(fixtureA.GetFriction(),fixtureB.GetFriction());				if (entityA.getType() == PhysicalEntity.CREATURE)			{				var creatureA:Creature = entityA as Creature				if (creatureA.getFeet() == fixtureA)				{					creatureA.setCanJump(true);					if(creatureA.getDirection().x != 0.0)					{						creatureA.setGrip(friction);						fixtureA.SetFriction(0.0);					}				}				creatureA = null;			}			if (entityB.getType() == PhysicalEntity.CREATURE)			{				var creatureB:Creature = entityB as Creature				if (creatureB.getFeet() == fixtureB)				{					creatureA.setCanJump(true);					if(creatureB.getDirection().x != 0.0)					{						creatureB.setGrip(friction);						fixtureB.SetFriction(0.0);					}				}				creatureB = null;			}						if (entityA.isDead())			{				contact.SetEnabled(false);			}			if (entityB.isDead())			{				contact.SetEnabled(false);			}			worldManifold = null;			state1 = null;			state2 = null;			fixtureA = null;			fixtureB = null;			bodyA = null;			bodyB = null;			entityA = null;			entityB = null;		}		/**		 * This lets you inspect a contact after the solver is finished. This is useful		 * for inspecting impulses.		 * Note: the contact manifold does not include time of impact impulses, which can be		 * arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly		 * in a separate data structure.		 * Note: this is only called for contacts that are touching, solid, and awake.		 */		override public function PostSolve(contact:b2Contact, impulse:b2ContactImpulse):void		{		}	}}import Box2D.Collision.b2Manifold;import Box2D.Common.b2Settings;import Box2D.Collision.b2ContactID;class b2PointState{;static public const NULL_STATE:uint = 0;static public const REMOVE_STATE:uint = 1;static public const ADD_STATE:uint = 2;static public const PERSIST_STATE:uint = 3;}function b2GetPointStates(state1:Vector.<uint >, state2:Vector.<uint >, manifold1:b2Manifold, manifold2:b2Manifold):void{var id:b2ContactID;for (var i:int = 0; i < b2Settings.b2_maxManifoldPoints; i++){	state1[i] = b2PointState.NULL_STATE;	state2[i] = b2PointState.NULL_STATE;}// Detect persists and removes.for (var j:int = 0; j < manifold1.m_pointCount; j++){	id = manifold1.m_points[j].m_id;	state1[j] = b2PointState.REMOVE_STATE;	for (var jj:int = 0; jj < manifold2.m_pointCount; jj++)	{		if (manifold2.m_points[jj].m_id.key == id.key)		{			state1[j] = b2PointState.PERSIST_STATE;			break;		}	}}// Detect persists and adds.for (var k:int = 0; k < manifold2.m_pointCount; k++){	id = manifold1.m_points[k].m_id;	state2[k] = b2PointState.ADD_STATE;	for (var kk:int = 0; kk < manifold1.m_pointCount; kk++)	{		if (manifold1.m_points[kk].m_id.key == id.key)		{			state2[k] = b2PointState.PERSIST_STATE;			break;		}	}}id = null;}